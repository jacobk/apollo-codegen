{"version":3,"sources":["../src/cli.js"],"names":["on","error","handleError","exit","command","output","demand","describe","default","normalize","coerce","resolve","header","alias","type","arg","additionalHeaders","split","name","value","insecure","argv","schema","urlRegex","test","target","choices","input","length","hasMagic","sync","inputPaths","map","options","passthroughCustomScalars","customScalarsPrefix","fail","message","help","version","strict"],"mappings":"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","file":"cli.js","sourcesContent":["\n\nimport glob from 'glob';\nimport process from 'process';\nimport path from 'path';\nimport yargs from 'yargs';\n\nimport { downloadSchema, introspectSchema, generate } from '.';\nimport { ToolError, logError } from './errors'\n\nimport 'source-map-support/register'\n\n// Make sure unhandled errors in async code are propagated correctly\nprocess.on('unhandledRejection', (error) => { throw error });\n\nprocess.on('uncaughtException', handleError);\n\nfunction handleError(error) {\n  logError(error);\n  process.exit(1);\n}\n\nyargs\n  .command(\n    ['introspect-schema <schema>', 'download-schema'],\n    'Generate an introspection JSON from a local GraphQL file or from a remote GraphQL server',\n    {\n      output: {\n        demand: true,\n        describe: 'Output path for GraphQL schema file',\n        default: 'schema.json',\n        normalize: true,\n        coerce: path.resolve,\n      },\n      header: {\n        alias: 'H',\n        describe: 'Additional header to send to the server as part of the introspection query request',\n        type: 'array',\n        coerce: (arg) => {\n          let additionalHeaders = {};\n          for (const header of arg) {\n            const [name, value] = header.split(/\\s*:\\s*/);\n            if (!(name && value)) {\n              throw new ToolError('Headers should be specified as \"Name: Value\"');\n            }\n            additionalHeaders[name] = value;\n          }\n          return additionalHeaders;\n        }\n      },\n      insecure: {\n        alias: 'K',\n        describe: 'Allows \"insecure\" SSL connection to the server',\n        type: 'boolean'\n      }\n    },\n    async argv => {\n      const { schema, output, header, insecure } = argv;\n      \n      const urlRegex = /^https?:\\/\\//i;\n      if (urlRegex.test(schema)) {\n        await downloadSchema(schema, output, header, insecure);\n      } else {\n        await introspectSchema(schema, output);\n      } \n    }\n  )\n  .command(\n    'generate [input...]',\n    'Generate code from a GraphQL schema and query documents',\n    {\n      schema: {\n        demand: true,\n        describe: 'Path to GraphQL schema file',\n        default: 'schema.json',\n        normalize: true,\n        coerce: path.resolve,\n      },\n      output: {\n        describe: 'Output directory for the generated files',\n        normalize: true,\n        coerce: path.resolve,\n      },\n      target: {\n        demand: false,\n        describe: 'Code generation target language',\n        choices: ['swift', 'json', 'ts', 'typescript', 'flow'],\n        default: 'swift'\n      },\n      \"passthrough-custom-scalars\": {\n        demand: false,\n        describe: \"Don't attempt to map custom scalars [temporary option]\",\n        default: false\n      },\n      \"custom-scalars-prefix\": {\n        demand: false,\n        describe: \"Prefix for custom scalars. (Implies that passthrough-custom-scalars is true if set)\",\n        default: '',\n        normalize: true\n      }\n    },\n    argv => {\n      let { input } = argv;\n\n      // Use glob if the user's shell was unable to expand the pattern\n      if (input.length === 1 && glob.hasMagic(input[0])) {\n        input = glob.sync(input[0]);\n      }\n      const inputPaths = input.map(input => path.resolve(input));\n\n      const options = { passthroughCustomScalars: argv[\"passthrough-custom-scalars\"] || argv[\"custom-scalars-prefix\"] !== '', customScalarsPrefix: argv[\"custom-scalars-prefix\"] || '' };\n      generate(inputPaths, argv.schema, argv.output, argv.target, options);\n    },\n  )\n  .fail(function(message, error) {\n    handleError(error ? error : new ToolError(message));\n  })\n  .help()\n  .version()\n  .strict()\n  .argv\n"]}