{"version":3,"sources":["../src/compilation.js"],"names":["compileToIR","printIR","builtInScalarTypes","isBuiltInScalarType","type","has","schema","document","compiler","Compiler","operations","forEach","operation","name","value","compileOperation","fragments","fragment","compileFragment","typesUsed","constructor","typesUsedSet","fragmentMap","definition","definitions","kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","compiledFragmentMap","addTypeUsed","add","field","getFields","fragmentNamed","fragmentName","operationDefinition","filePath","operationName","operationType","variables","variableDefinitions","map","node","variable","source","withTypenameFieldAddedWhereNeeded","rootType","groupedVisitedFragmentSet","groupedFieldSet","collectFields","selectionSet","undefined","fragmentsReferencedSet","resolveFields","fields","fragmentsReferenced","fragmentDefinition","typeCondition","possibleTypes","possibleTypesForType","fragmentSpreads","inlineFragments","parentType","Error","String","selection","selections","FIELD","fieldName","responseName","alias","args","argumentsFromAST","arguments","directives","INLINE_FRAGMENT","inlineFragmentType","effectiveType","FRAGMENT_SPREAD","fragmentType","visitedFragmentSet","get","set","getPossibleTypes","mergeSelectionSets","fieldSet","filter","length","firstField","isConditional","some","directive","directiveName","bareType","subSelectionGroupedVisitedFragmentSet","subSelectionGroupedFieldSet","fragmentSpreadsForParentType","resolveInlineFragments","values","fragmentsReferencedFromFragment","fragmentReferenced","collectPossibleTypes","isPossibleType","keys","typenameField","NAME","ast","isOperationRootType","getQueryType","getMutationType","getSubscriptionType","typeInfo","leave","SelectionSet","getParentType","sourceAt","location","body","slice","start","end","arg","concat","inlineFragment"],"mappings":"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","file":"compilation.js","sourcesContent":["import {\n  print,\n  visit,\n  visitWithTypeInfo,\n  typeFromAST,\n  getNamedType,\n  isAbstractType,\n  isEqualType,\n  isTypeSubTypeOf,\n  Kind,\n  TypeInfo,\n  isType,\n  isCompositeType,\n  GraphQLScalarType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n  GraphQLError\n} from 'graphql';\n\nimport {\n  isTypeProperSuperTypeOf,\n  getOperationRootType,\n  getFieldDef,\n  valueFromValueNode,\n  filePathForNode\n} from './utilities/graphql';\n\nimport {\n  join,\n  block,\n  wrap,\n  indent\n} from './utilities/printing';\n\nconst builtInScalarTypes = new Set([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);\n\nfunction isBuiltInScalarType(type) {\n  return builtInScalarTypes.has(type);\n}\n\n// Parts of this code are adapted from graphql-js\n\nexport function compileToIR(schema, document) {\n  const compiler = new Compiler(schema, document);\n\n  const operations = Object.create(null);\n\n  compiler.operations.forEach(operation => {\n    operations[operation.name.value] = compiler.compileOperation(operation)\n  });\n\n  const fragments = Object.create(null);\n\n  compiler.fragments.forEach(fragment => {\n    fragments[fragment.name.value] = compiler.compileFragment(fragment)\n  });\n\n  const typesUsed = compiler.typesUsed;\n\n  return { schema, operations, fragments, typesUsed };\n}\n\nexport class Compiler {\n  constructor(schema, document) {\n    this.schema = schema;\n\n    this.typesUsedSet = new Set();\n\n    this.fragmentMap = Object.create(null);\n    this.operations = [];\n\n    for (const definition of document.definitions) {\n      switch (definition.kind) {\n        case Kind.OPERATION_DEFINITION:\n          this.operations.push(definition);\n          break;\n        case Kind.FRAGMENT_DEFINITION:\n          this.fragmentMap[definition.name.value] = definition;\n          break;\n      }\n    }\n\n    this.compiledFragmentMap = Object.create(null);\n  }\n\n  addTypeUsed(type) {\n    if (type instanceof GraphQLEnumType ||\n        type instanceof GraphQLInputObjectType ||\n        (type instanceof GraphQLScalarType && !isBuiltInScalarType(type))) {\n      this.typesUsedSet.add(type);\n    }\n    if (type instanceof GraphQLInputObjectType) {\n      for (const field of Object.values(type.getFields())) {\n        this.addTypeUsed(getNamedType(field.type));\n      }\n    }\n  }\n\n  get typesUsed() {\n    return Array.from(this.typesUsedSet);\n  }\n\n  fragmentNamed(fragmentName) {\n    return this.fragmentMap[fragmentName];\n  }\n\n  get fragments() {\n    return Object.values(this.fragmentMap);\n  }\n\n  compileOperation(operationDefinition) {\n    const filePath = filePathForNode(operationDefinition);\n    const operationName = operationDefinition.name.value;\n    const operationType = operationDefinition.operation;\n\n    const variables = operationDefinition.variableDefinitions.map(node => {\n      const name = node.variable.name.value;\n      const type = typeFromAST(this.schema, node.type);\n      this.addTypeUsed(getNamedType(type));\n      return { name, type };\n    });\n\n    const source = print(withTypenameFieldAddedWhereNeeded(this.schema, operationDefinition));\n\n    const rootType = getOperationRootType(this.schema, operationDefinition);\n\n    const groupedVisitedFragmentSet = new Map();\n    const groupedFieldSet = this.collectFields(rootType, operationDefinition.selectionSet, undefined, groupedVisitedFragmentSet);\n\n    const fragmentsReferencedSet = Object.create(null);\n    const { fields } = this.resolveFields(rootType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n    const fragmentsReferenced = Object.keys(fragmentsReferencedSet);\n\n    return { filePath, operationName, operationType, variables, source, fields, fragmentsReferenced };\n  }\n\n  compileFragment(fragmentDefinition) {\n    const filePath = filePathForNode(fragmentDefinition);\n    const fragmentName = fragmentDefinition.name.value;\n\n    const source = print(withTypenameFieldAddedWhereNeeded(this.schema, fragmentDefinition));\n\n    const typeCondition = typeFromAST(this.schema, fragmentDefinition.typeCondition);\n    const possibleTypes = this.possibleTypesForType(typeCondition)\n\n    const groupedVisitedFragmentSet = new Map();\n    const groupedFieldSet = this.collectFields(typeCondition, fragmentDefinition.selectionSet, undefined, groupedVisitedFragmentSet);\n\n    const fragmentsReferencedSet = Object.create(null);\n    const { fields, fragmentSpreads, inlineFragments } = this.resolveFields(typeCondition, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n    const fragmentsReferenced = Object.keys(fragmentsReferencedSet);\n\n    return { filePath, fragmentName, source, typeCondition, possibleTypes, fields, fragmentSpreads, inlineFragments, fragmentsReferenced };\n  }\n\n  collectFields(parentType, selectionSet, groupedFieldSet = Object.create(null), groupedVisitedFragmentSet = new Map()) {\n    if (!isCompositeType(parentType)) {\n      throw new Error(`parentType should be a composite type, but is \"${String(parentType)}\"`);\n    }\n\n    for (const selection of selectionSet.selections) {\n      switch (selection.kind) {\n        case Kind.FIELD: {\n          const fieldName = selection.name.value;\n          const responseName = selection.alias ? selection.alias.value : fieldName;\n\n          const field = getFieldDef(this.schema, parentType, selection);\n          if (!field) {\n            throw new GraphQLError(`Cannot query field \"${fieldName}\" on type \"${String(parentType)}\"`, [selection]);\n          }\n\n          if (groupedFieldSet) {\n            if (!groupedFieldSet[responseName]) {\n              groupedFieldSet[responseName] = [];\n            }\n\n            groupedFieldSet[responseName].push([parentType, {\n              responseName,\n              fieldName,\n              args: argumentsFromAST(selection.arguments),\n              type: field.type,\n              directives: selection.directives,\n              selectionSet: selection.selectionSet\n            }]);\n          }\n          break;\n        }\n        case Kind.INLINE_FRAGMENT: {\n          const typeCondition = selection.typeCondition;\n          const inlineFragmentType = typeCondition ?\n            typeFromAST(this.schema, typeCondition) :\n            parentType;\n\n          const effectiveType = parentType instanceof GraphQLObjectType ? parentType : inlineFragmentType;\n\n          this.collectFields(\n            effectiveType,\n            selection.selectionSet,\n            groupedFieldSet,\n            groupedVisitedFragmentSet\n          );\n          break;\n        }\n        case Kind.FRAGMENT_SPREAD: {\n          const fragmentName = selection.name.value;\n\n          const fragment = this.fragmentNamed(fragmentName);\n          if (!fragment) throw new GraphQLError(`Cannot find fragment \"${fragmentName}\"`);\n\n          const typeCondition = fragment.typeCondition;\n          const fragmentType = typeFromAST(this.schema, typeCondition)\n\n          if (groupedVisitedFragmentSet) {\n            let visitedFragmentSet = groupedVisitedFragmentSet.get(parentType);\n            if (!visitedFragmentSet) {\n              visitedFragmentSet = {};\n              groupedVisitedFragmentSet.set(parentType, visitedFragmentSet);\n            }\n\n            if (visitedFragmentSet[fragmentName]) continue;\n            visitedFragmentSet[fragmentName] = true;\n          }\n\n          const effectiveType = parentType instanceof GraphQLObjectType ? parentType : fragmentType;\n\n          this.collectFields(\n            effectiveType,\n            fragment.selectionSet,\n            null,\n            groupedVisitedFragmentSet\n          );\n          break;\n        }\n      }\n    }\n\n    return groupedFieldSet;\n  }\n\n  possibleTypesForType(type) {\n    if (isAbstractType(type)) {\n      return this.schema.getPossibleTypes(type);\n    } else {\n      return [type];\n    }\n  }\n\n  mergeSelectionSets(parentType, fieldSet, groupedVisitedFragmentSet) {\n    const groupedFieldSet = Object.create(null);\n\n    for (const [,field] of fieldSet) {\n      const selectionSet = field.selectionSet;\n\n      if (selectionSet) {\n        this.collectFields(parentType, selectionSet, groupedFieldSet, groupedVisitedFragmentSet);\n      }\n    }\n\n    return groupedFieldSet;\n  }\n\n  resolveFields(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet) {\n    const fields = [];\n\n    for (let [responseName, fieldSet] of Object.entries(groupedFieldSet)) {\n      fieldSet = fieldSet.filter(([typeCondition,]) => isTypeSubTypeOf(this.schema, parentType, typeCondition));\n      if (fieldSet.length < 1) continue;\n\n      const [,firstField] = fieldSet[0];\n      const fieldName = firstField.fieldName;\n      const args = firstField.args;\n      const type = firstField.type;\n\n      let field = { responseName, fieldName, type };\n\n      if (args && args.length > 0) {\n        field.args = args;\n      }\n\n      const isConditional = fieldSet.some(([,field]) => {\n        return field.directives && field.directives.some(directive => {\n          const directiveName = directive.name.value;\n          return directiveName == 'skip' || directiveName == 'include';\n        });\n      });\n\n      if (isConditional) {\n        field.isConditional = true;\n      }\n\n      const bareType = getNamedType(type);\n\n      this.addTypeUsed(bareType);\n\n      if (isCompositeType(bareType)) {\n        const subSelectionGroupedVisitedFragmentSet = new Map();\n        const subSelectionGroupedFieldSet = this.mergeSelectionSets(\n          bareType,\n          fieldSet,\n          subSelectionGroupedVisitedFragmentSet\n        );\n\n        const { fields, fragmentSpreads, inlineFragments } = this.resolveFields(\n          bareType,\n          subSelectionGroupedFieldSet,\n          subSelectionGroupedVisitedFragmentSet,\n          fragmentsReferencedSet\n        );\n        Object.assign(field, { fields, fragmentSpreads, inlineFragments });\n      }\n\n      fields.push(field);\n    }\n\n    const fragmentSpreads = this.fragmentSpreadsForParentType(parentType, groupedVisitedFragmentSet);\n    const inlineFragments = this.resolveInlineFragments(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n\n    if (fragmentsReferencedSet) {\n      Object.assign(fragmentsReferencedSet, ...groupedVisitedFragmentSet.values());\n\n      // TODO: This is a really inefficient way of keeping track of fragments referenced by other fragments\n      // We need to either cache compiled fragments or find a way to make resolveFields smarter\n      for (let fragmentName of fragmentSpreads) {\n        const fragment = this.fragmentNamed(fragmentName);\n        if (!fragment) throw new GraphQLError(`Cannot find fragment \"${fragmentName}\"`);\n        const { fragmentsReferenced: fragmentsReferencedFromFragment } = this.compileFragment(fragment);\n        for (let fragmentReferenced of fragmentsReferencedFromFragment) {\n          fragmentsReferencedSet[fragmentReferenced] = true;\n        }\n      }\n    }\n\n    return { fields, fragmentSpreads, inlineFragments };\n  }\n\n  resolveInlineFragments(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet) {\n    return this.collectPossibleTypes(parentType, groupedFieldSet, groupedVisitedFragmentSet).map(typeCondition => {\n      const { fields, fragmentSpreads } = this.resolveFields(\n        typeCondition,\n        groupedFieldSet,\n        groupedVisitedFragmentSet,\n        fragmentsReferencedSet\n      );\n      const possibleTypes = this.possibleTypesForType(typeCondition)\n      return { typeCondition, possibleTypes, fields, fragmentSpreads };\n    });\n  }\n\n  collectPossibleTypes(parentType, groupedFieldSet, groupedVisitedFragmentSet) {\n    if (!isAbstractType(parentType)) return [];\n\n    const possibleTypes = new Set();\n\n    for (const fieldSet of Object.values(groupedFieldSet)) {\n      for (const [typeCondition,] of fieldSet) {\n        if (this.schema.isPossibleType(parentType, typeCondition)) {\n          possibleTypes.add(typeCondition);\n        }\n      }\n    }\n\n    // Also include type conditions for fragment spreads\n    if (groupedVisitedFragmentSet) {\n      for (const effectiveType of groupedVisitedFragmentSet.keys()) {\n        if (this.schema.isPossibleType(parentType, effectiveType)) {\n          possibleTypes.add(effectiveType);\n        }\n      }\n    }\n\n    return Array.from(possibleTypes);\n  }\n\n  fragmentSpreadsForParentType(parentType, groupedVisitedFragmentSet) {\n    if (!groupedVisitedFragmentSet) return [];\n\n    let fragmentSpreads = new Set();\n\n    for (const [effectiveType, visitedFragmentSet] of groupedVisitedFragmentSet) {\n      if (!isTypeProperSuperTypeOf(this.schema, effectiveType, parentType)) continue;\n\n      for (const fragmentName of Object.keys(visitedFragmentSet)) {\n        fragmentSpreads.add(fragmentName);\n      }\n    }\n\n    return Array.from(fragmentSpreads);\n  }\n}\n\nconst typenameField = { kind: Kind.FIELD, name: { kind: Kind.NAME, value: '__typename' } };\n\nfunction withTypenameFieldAddedWhereNeeded(schema, ast) {\n  function isOperationRootType(type) {\n    return type === schema.getQueryType() ||\n      type === schema.getMutationType() ||\n      type === schema.getSubscriptionType();\n  }\n\n  const typeInfo = new TypeInfo(schema);\n\n  return visit(ast, visitWithTypeInfo(typeInfo, {\n    leave: {\n      SelectionSet: node => {\n        const parentType = typeInfo.getParentType();\n\n        if (!isOperationRootType(parentType)) {\n          return { ...node, selections: [typenameField, ...node.selections] };\n        }\n      }\n    }\n  }));\n}\n\nfunction sourceAt(location) {\n  return location.source.body.slice(location.start, location.end);\n}\n\nfunction argumentsFromAST(args) {\n  return args.map(arg => {\n    return { name: arg.name.value, value: valueFromValueNode(arg.value) };\n  });\n}\n\nexport function printIR({ fields, inlineFragments, fragmentSpreads }) {\n  return fields && wrap('<', join(fragmentSpreads, ', '), '> ')\n    + block(fields.map(field =>\n      `${field.name}: ${String(field.type)}` + wrap(' ', printIR(field))\n    ).concat(inlineFragments && inlineFragments.map(inlineFragment =>\n      `${String(inlineFragment.typeCondition)}` + wrap(' ', printIR(inlineFragment)))));\n}\n"]}